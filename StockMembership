// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract IndoorGameToken is ERC20, Ownable {
    enum GameLevel { Beginner, Intermediate, Advanced }

    event GameTokenAcquired(
        address indexed player,
        GameLevel level,
        uint256 tokenCost
    );

    mapping(address => GameLevel) public playerLevels;

    uint256 public constant BeginnerTokenCost = 500;
    uint256 public constant IntermediateTokenCost = 750;
    uint256 public constant AdvancedTokenCost = 1000;

    constructor(address initialOwner) ERC20("GameTokens", "GAMETOK") Ownable(initialOwner) {}

    function mintTokens(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function burnTokens(uint256 amount) public {
        require(amount > 0, "Amount to burn must be greater than zero");
        require(balanceOf(msg.sender) >= amount, "Insufficient funds to burn tokens");
        _burn(msg.sender, amount);
    }

    function RedeeemGameToken(uint8 levelNumber) public {
        require(levelNumber >= 1 && levelNumber <= 3, "Invalid game level");

        GameLevel level;
        uint256 tokenCost;

        if (levelNumber == 1) {
            require(balanceOf(msg.sender) >= BeginnerTokenCost, "Insufficient funds for token acquisition");
            level = GameLevel.Beginner;
            tokenCost = BeginnerTokenCost;
            _burn(msg.sender, tokenCost);
        } else if (levelNumber == 2) {
            require(balanceOf(msg.sender) >= IntermediateTokenCost, "Insufficient funds for token acquisition");
            level = GameLevel.Intermediate;
            tokenCost = IntermediateTokenCost;
            _burn(msg.sender, tokenCost);
        } else {
            require(balanceOf(msg.sender) >= AdvancedTokenCost, "Insufficient funds for token acquisition");
            level = GameLevel.Advanced;
            tokenCost = AdvancedTokenCost;
            _burn(msg.sender, tokenCost);
        }

        playerLevels[msg.sender] = level;
        emit GameTokenAcquired(msg.sender, level, tokenCost);
    }

    function transferGameTokens(address to, uint256 amount) external {
        require(to != address(0), "Invalid recipient address");
        require(balanceOf(msg.sender) >= amount, "Insufficient funds to transfer tokens");
        _transfer(msg.sender, to, amount);
    }
}
